@using Microsoft.JSInterop;
@using System.Text.Json;
@using Vizor.ECharts;
@using Vizor.ECharts.Internal;

@namespace Vizor.ECharts

@inject IJSRuntime jsRuntime
@implements IAsyncDisposable

<div id="@Id" class="@CssClass" style="@Style"></div>

@code {

	//REMARK: do NOT mark this as static, we want 1 instance per chart since we abuse it to detect JS function/external data source mapping.
	// see SpecialObjectMapper class for more details
	private readonly JsonSerializerOptions jsonOpts = SpecialObjectMapper.CreateOptions();

	[Parameter]
	public string Id { get; set; } = "chart-" + Guid.NewGuid().ToString();

	[Parameter]
	public string? CssClass { get; set; }

	[Parameter]
	public string? Style { get; set; }

	[Parameter]
	public string? Width { get; set; }

	[Parameter]
	public string? Height { get; set; }

	[Parameter]
	public string? Theme { get; set; }

	/// <summary>
	/// Function used to retrieve data from external sources.
	/// </summary>
	[Parameter]
	public EventCallback DataLoader { get; set; }

	[Parameter, EditorRequired]
	public ChartOptions Options { get; set; } = default!;

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		// echarts.init the very first time the component is rendered

		if (!firstRender)
			return;

		if (Options == null)
			throw new ArgumentException("Options property must be set");
		if (string.IsNullOrWhiteSpace(Id))
			throw new ArgumentException("Id property must be set");

		if (DataLoader.HasDelegate)
		{
			// init the chart without any data
			await jsRuntime.InvokeVoidAsync("vizorECharts.initChart", Id, Theme, Width, Height, null, false);

			// retrieve the data
			if (DataLoader.HasDelegate)
			{
				await DataLoader.InvokeAsync();
			}

			// update the chart
			(string chartOpts, bool mapSpecialObjects) = SerializeOptions();
			await jsRuntime.InvokeVoidAsync("vizorECharts.updateChart", Id, chartOpts, mapSpecialObjects);
		}
		else
		{
			(string chartOpts, bool mapSpecialObjects) = SerializeOptions();

			//TODO: also pass DotNetObjectReference.Create(this) ?
			await jsRuntime.InvokeVoidAsync("vizorECharts.initChart", Id, Theme, Width, Height, chartOpts, mapSpecialObjects);
		}
	}

	public async ValueTask DisposeAsync()
	{
		try
		{
			await jsRuntime.InvokeVoidAsync("vizorECharts.disposeChart", Id);
		}
		catch { }
	}

	public async Task UpdateAsync(bool executeDataLoader = true)
	{
		if (executeDataLoader && DataLoader.HasDelegate)
		{
			await DataLoader.InvokeAsync();
		}

		(string chartOpts, bool mapSpecialObjects) = SerializeOptions();
		await jsRuntime.InvokeVoidAsync("vizorECharts.updateChart", Id, chartOpts, mapSpecialObjects);
	}

	private (string chartOpts, bool mapSpecialObjects) SerializeOptions()
	{
		// REMARK: the ChartOptions can contain multiple JavascriptFunction, ExternalDataSource, ... objects.
		// IF we serialize them, the vizorECharts.initChart function must iterate the ENTIRE object and replace the content dynamically.
		// This can be very expensive in big charts
		//
		// Since JsonSerializer doesn't have a state, we have no way of knowing if any of the properties that were serialized is a JavascriptFunction, ExternalDataSource, ... .
		// We solve this using the SpecialObjectMapper class

		SpecialObjectMapper.ClearFlags(jsonOpts);
		var chartOpts = JsonSerializer.Serialize(Options, jsonOpts);

		return (chartOpts, SpecialObjectMapper.ShouldMapSpecialObjects(jsonOpts));
	}
}
